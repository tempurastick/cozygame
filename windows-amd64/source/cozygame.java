/* autogenerated by Processing revision 1293 on 2024-02-17 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class cozygame extends PApplet {


SoundFile song;

Map map;

GameScreens gameScreen;

Player player;
ArrayList<Crops> cropList = new ArrayList<Crops>();

UI ui;
Font pixelFont;

// Will be set by restart
float goalX=0, goalY=0;
// Whether to illustrate special functions of class Map
boolean showSpecialFunctions=false;

// left / top border of the screen in map coordinates
// used for scrolling
float screenLeftX, screenTopY;

Map.TileReference soil;

InteractionHandler interactionHandler = new InteractionHandler();
ObserverSubject observerSubject = new ObserverSubject();

public void setup() {
  gameScreen = new GameScreens();
  /* size commented out by preprocessor */;
  pixelFont = new Font();
  frameRate(30);
  ui = new UI();
  ui.setup();
  song = new SoundFile(this, "mushrooms.mp3");
  song.loop();

  observerSubject.addObserver(interactionHandler);
  gameScreen.newGame();
}

public void draw() {
  if ( gameScreen.gameState == gameScreen.GAMEWAIT ) {
    gameScreen.startScreen();
  } else if ( gameScreen.gameState == gameScreen.GAMERUNNING ) {
    gameScreen.gameRunningScreen();
  } else if (gameScreen.gameState == gameScreen.GAMEOVER) {
    gameScreen.gameOverScreen();
  } else if (gameScreen.gameState == gameScreen.GAMEWON) {
    gameScreen.gameWonScreen();
  } else if (gameScreen.gameState == gameScreen.GAMERESTART) {
    gameScreen.resetState();
  } else if (gameScreen.gameState == gameScreen.GAMEHELP) {
    gameScreen.helpScreen();
  }
}

public void keyPressed() {
  if (gameScreen.gameState == gameScreen.GAMERUNNING) {
    player.keyPressed();
  }
}
class GameScreens {
  int GAMEWAIT=0, GAMERUNNING=1, GAMEOVER=2, GAMEWON=3, GAMERESTART=4, GAMEHELP=5;
  int gameState;
  float time;
  PImage startScreenLogo;
  PImage helpScreen;
  int greenBg = 0xFFD4DFB7;
  
  boolean scoreSaved = false;

  JSONObject json;

  GameScreens() {
    startScreenLogo = loadImage("images/startscreen.png");
    helpScreen = loadImage("images/helpscreen.png");
  }

  public void startScreen() {
    gameState = GAMEWAIT;
    background(greenBg);
    image(startScreenLogo, 50, 50);
    pixelFont.draw("ENTER zum start", 50, height/2);
    pixelFont.draw("SPACE zur Anleitung", 50, height/2+32);
    loadData();
    if (keyPressed) {
      if ( key == ENTER || key == RETURN ) {
        gameState = GAMERUNNING;
      } else if (key == ' ') {
        gameState = GAMEHELP;
      }
    }
  }

  public int returnGameState() {
    return gameState;
  }

  public void gameRunningScreen() {
    player.updatePlayer();
    time+=1/frameRate;
    drawMap();

    for ( Crops crop : cropList ) {
      crop.registerObserver(observerSubject);
      crop.draw();
    }
    // display player
    player.drawPlayer();
    // display menu
    ui.draw();

    if ( keyPressed && (key == 'p' || key == 'P')) {
      gameState = GAMEHELP;
    }

    if ( player.actionCount >= 50 ) {
      // update for whether enough points are accumulated. Also I should probably clean this and use the notify
      if ((player.pointsAdded*2) <= 200) {
        gameState = GAMEOVER;
      } else {
        gameState = GAMEWON;
      }
    }
  }

  public void newGame () {
    map = new Map( "demo.map");
    player = new Player();
    for ( int x = 0; x < map.w; ++x ) {
      for ( int y = 0; y < map.h; ++y ) {
        // put player at 'S' tile and replace with 'F'
        if ( map.at(x, y) == 'S' ) {
          player.playerX = map.centerXOfTile (x);
          player.playerY = map.centerYOfTile (y);
          map.set(x, y, 'F');
        }
        // put goal at 'E' tile
        if ( map.at(x, y) == 'E' ) {
          goalX = map.centerXOfTile (x);
          goalY = map.centerYOfTile (y);
        }
      }
    }
    time=0;

    player.setPlayerPos(50, 50);

    gameState = GAMEWAIT;
  }

  public float map (float x, float xRef, float yRef, float factor) {
    return factor*(x-xRef)+yRef;
  }


  public void drawMap() {
    // The left border of the screen is at screenLeftX in map coordinates
    // so we draw the left border of the map at -screenLeftX in screen coordinates
    // Same for screenTopY.
    map.draw( -screenLeftX, -screenTopY );
  }

  public void gameOverScreen() {
    if (!scoreSaved) {
      saveData();
      scoreSaved = true;
    }
    background(greenBg);
    gameState = GAMEOVER;
    pixelFont.draw("Leider hat Bob gewonnen...", 50, 77+16);
    pixelFont.draw("Punkte:" + totalPoints(), 50, height/2-40);
    pixelFont.draw("zum Neustarten ", 50, height/2);
    pixelFont.draw("ENTER eingeben", 50, (height/2)+16);

    if (keyPressed && (key == ENTER || key == RETURN ) ) {
      gameState = GAMERESTART;
    }
  }

  public void gameWonScreen() {
    if (!scoreSaved) {
      saveData();
      scoreSaved = true;
    }

    background(greenBg);
    gameState = GAMEWON;
    pixelFont.draw("Take that Bob!", 50, 77+16);
    pixelFont.draw("Punkte:" + totalPoints(), 50, height/2-40);
    pixelFont.draw("zum Neustarten ", 50, height/2);
    pixelFont.draw("ENTER eingeben", 50, (height/2)+16);

    if (keyPressed && (key == ENTER || key == RETURN ) ) {
      gameState = GAMERESTART;
    }
  }

  public String totalPoints() {
    String pointsTotal = str(player.pointsAdded*2);
    return pointsTotal;
  }

  public void saveData() {
    if (!json.hasKey("High Score")) {
      json.setJSONArray("High Score", new JSONArray());
    }

    JSONObject highScore = new JSONObject();
    highScore.setInt("Punkte", player.pointsAdded*2);

    JSONArray highScoreData = json.getJSONArray("High Score");
    highScoreData.append(highScore);

    saveJSONObject(json, "data/data.json");
    loadData();
    loadData();
  }

  public void loadData() {
    json = loadJSONObject("data/data.json");

    if (json != null && json.hasKey("High Score")) {
      JSONArray highScoreData = json.getJSONArray("High Score");

      if (highScoreData.size()> 0) {
        int highestScore = Integer.MIN_VALUE;

        // grab highest score saved
        for (int i = 0; i < highScoreData.size(); i++) {
          JSONObject highScore = highScoreData.getJSONObject(i);
          int scoreValue = highScore.getInt("Punkte");
          highestScore = Math.max(highestScore, scoreValue);
        }

        // if score found:
        String scoreStr = str(highestScore);
        pixelFont.draw("High Score:" + scoreStr, 50, height/2+48);
      }
    }
  }

  public void resetState() {
    cropList.clear();
    scoreSaved = false;
    newGame();
    gameState = GAMEWAIT;
  }

  public void helpScreen() {
    gameState = GAMEHELP;
    background(greenBg);
    image(helpScreen, 0, 0);
    pixelFont.draw("Bisher hatte Bob jedes Jahr die beste", 156, 92);
    pixelFont.draw("Ernte. Doch dieses Jahr... komme ich!", 156, 92+20);
    pixelFont.draw("Anleitung:", 40, 200);
    pixelFont.draw("Du hast 50 Tage (Aktionen) Zeit", 214, 200);
    pixelFont.draw("WASD zum Bewegen", 40, 268);
    pixelFont.draw("Wasser: Q", 462, 268);
    pixelFont.draw("H", 508, 308);
    pixelFont.draw("Ernte:   X", 462, 312+20);
    pixelFont.draw("Q", 508+24, 308);
    pixelFont.draw("Auswahl mit Pfeiltasten", 40, 312);
    pixelFont.draw("X zum pflanzen", 40, 312+20);
    pixelFont.draw("13   25  8   5   25   6", 40, 378);
    pixelFont.draw("0", 554, 378);
    pixelFont.draw("Enter zum Fortfahren", 40, height-42);
    if (keyPressed && (key == ENTER || key == RETURN )) {
      gameState = GAMERUNNING;
    }
  }
}
class Map extends ObserverSubject
{
  int mode = CORNER;
  String emptyField = "D";
  String grass = "F";
  String tilled = "H";
  String tilledWatered = "M";

  // Constructor: tmptileSize is the width/height of one tile in pixel
  Map( int tmptileSize ) {
    tileSize = tmptileSize;
    images = new PImage[26];
  }

  // Constructor: Loads a map file
  Map( String mapFile ) {
    images = new PImage[26];
    loadFile( mapFile );
  }

  //! Sets the mode in which coordinates are specified, supported is CORNER, CENTER, CORNERS
  public void mode (int tmpMode) {
    mode=tmpMode;
  }


  public int widthPixel() {
    return w * tileSize;
  }

  public int heightPixel() {
    return h * tileSize;
  }

  // Left border (pixel) of the tile at tile position x
  public int leftOfTile(int x) {
    return x * tileSize;
  }

  // Right border (pixel) of the tile at tile position x
  public int rightOfTile(int x) {
    return (x+1) * tileSize-1;
  }

  // Top border (pixel) of the tile at tile position y
  public int topOfTile(int y) {
    return y * tileSize;
  }

  // Bottom border (pixel) of the tile at tile position y
  public int bottomOfTile(int y) {
    return (y+1) * tileSize-1;
  }

  //! Center of the tile at tile position x
  public int centerXOfTile (int x) {
    return x*tileSize+tileSize/2;
  }

  //! Center of the tile at tile position x
  public int centerYOfTile (int y) {
    return y*tileSize+tileSize/2;
  }

  // Returns the tile at tile position x,y. '_' for invalid positions (out of range)
  public char at( int x, int y ) {
    if ( x < 0 || y < 0 || x >= w || y >= h )
      return '_';
    else
      return map[y].charAt(x);
  }

  // Returns the tile at pixel position 'x,y', '_' for invalid
  public char atPixel (float x, float y) {
    return at (floor(x/tileSize), floor(y/tileSize));
  }

  // Sets the tile at tile position x,y
  // Coordinates below 0 are ignored, for coordinates
  // beyond the map border, the map is extended
  public void set (int x, int y, char ch) {
    if ( x < 0 || y < 0 ) return;
    extend (x+1, y+1);
    map[y] = replace (map[y], x, ch);
  }

  // Sets the tile at image position 'x,y' see set
  public void setPixel (int x, int y, char ch) {
    set (x/tileSize, y/tileSize, ch);
  }


  // Reference to a tile in the map
  class TileReference {
    // Position in the map in tiles
    int x, y;
    // Position in the map in pixels
    // This position definitely belong to the tile (x,y)
    // where it is on the tile depents on the function returning this reference
    float xPixel, yPixel;
    // Type of the tile
    char tile;
    // Border of that tile in pixel
    int left, right, top, bottom;
    // Center of that tile in pixel
    int centerX, centerY;

    // Creates a reference to the tile at (x,y)
    // all other components are taken from the map
    TileReference (int tmpX, int tmpY) {
      x = tmpX;
      y = tmpY;
      setBorders();
      xPixel = centerX;
      yPixel = centerY;
    }

    // Computes tile, left, right, top, bottom, centerX, centerY from referenced tile
    public void setBorders() {
      tile = at(x, y);
      left = leftOfTile(x);
      right = rightOfTile(x);
      top = topOfTile(y);
      bottom = bottomOfTile(y);
      centerX =  centerXOfTile(x);
      centerY = centerYOfTile(y);
    }


    // Consider the line xPixel, yPixel towards goalX, goalY.
    // This line must start in tile x, y.
    // Then advanceTowards follows this line until it leaves x, y
    // updating xPixel,yPixel with the point where it leaves
    // and the rest with the tile it enters.
    public void advanceTowards (float goalX, float goalY)
    {
      float dX = goalX-xPixel;
      float dY = goalY-yPixel;
      // First try to go x until next tile
      float lambdaToNextX = Float.POSITIVE_INFINITY;
      if (dX>0) {
        float nextX = (x+1)*tileSize;
        lambdaToNextX = (nextX-xPixel)/dX;
      } else if (dX<0) {
        float nextX = x*tileSize;
        lambdaToNextX = (nextX-xPixel)/dX;
      }
      // Then try to go y until next tile
      float lambdaToNextY = Float.POSITIVE_INFINITY;
      if (dY>0) {
        float nextY = (y+1)*tileSize;
        lambdaToNextY = (nextY-yPixel)/dY;
      } else if (dY<0) {
        float nextY = y*tileSize;
        lambdaToNextY = (nextY-yPixel)/dY;
      }
      // Then choose which comes first x, y or goal
      if (lambdaToNextX<lambdaToNextY && lambdaToNextX<1) { // Go x
        xPixel += dX*lambdaToNextX;
        yPixel += dY*lambdaToNextX;
        if (dX>0) x++;
        else x--;
      } else if (lambdaToNextY<=lambdaToNextX && lambdaToNextY<1) { // Go y
        xPixel += dX*lambdaToNextY;
        yPixel += dY*lambdaToNextY;
        if (dY>0) y++;
        else y--;
      } else {// reached goal in same cell
        xPixel = goalX;
        yPixel = goalY;
      }
    }
  };

  // Returns a reference to a given pixel and its tile
  public TileReference newRefOfPixel (float pixelX, float pixelY) {
    TileReference ref = new TileReference (floor(pixelX/tileSize), floor(pixelY/tileSize));
    ref.xPixel = pixelX;
    ref.yPixel = pixelY;
    return ref;
  }


  // True if the rectangle given by x, y, w, h (partially) contains an element with a tile
  // from list. The meaning of x,y,w,h is governed by mode (CORNER, CENTER, CORNERS).
  public boolean testTileInRect( float x, float y, float w, float h, String list ) {
    if (mode==CENTER) {
      x-=w/2;
      y-=w/2;
    }
    if (mode==CORNERS) {
      w=w-x;
      h=h-y;
    }
    int startX = floor(x / tileSize),
      startY = floor(y / tileSize),
      endX   = floor((x+w) / tileSize),
      endY   = floor((y+h) / tileSize);

    for ( int xx = startX; xx <= endX; ++xx )
    {
      for ( int yy = startY; yy <= endY; ++yy )
      {
        if ( list.indexOf( at(xx, yy) ) != -1 )
          return true;
      }
    }
    return false;
  }

  // Like testtileInRect(...) but returns a reference to the tile if one is found
  // and null else. The meaning of x,y,w,h is governed by mode (CORNER, CENTER, CORNERS).
  public TileReference findTileInRect( float x, float y, float w, float h, String list ) {
    if (mode==CENTER) {
      x-=w/2;
      y-=w/2;
    }
    if (mode==CORNERS) {
      w=w-x;
      h=h-y;
    }
    int startX = floor(x / tileSize),
      startY = floor(y / tileSize),
      endX   = floor((x+w) / tileSize),
      endY   = floor((y+h) / tileSize);

    for ( int xx = startX; xx <= endX; ++xx )
    {
      for ( int yy = startY; yy <= endY; ++yy )
      {
        if ( list.indexOf( at(xx, yy) ) != -1 )
          return new TileReference(xx, yy);
      }
    }
    return null;
  }

  // Like findTileInRect(...) but returns a reference to the tile closest to the center
  public TileReference findClosestTileInRect( float x, float y, float w, float h, String list ) {
    if (mode==CENTER) {
      x-=w/2;
      y-=w/2;
    }
    if (mode==CORNERS) {
      w=w-x;
      h=h-y;
    }
    float centerX=x+w/2, centerY=y+h/2;
    int startX = floor(x / tileSize),
      startY = floor(y / tileSize),
      endX   = floor((x+w) / tileSize),
      endY   = floor((y+h) / tileSize);

    int xFound=-1, yFound=-1;
    float dFound = Float.POSITIVE_INFINITY;
    for ( int xx = startX; xx <= endX; ++xx )
    {
      for ( int yy = startY; yy <= endY; ++yy )
      {
        if ( list.indexOf( at(xx, yy) ) != -1 ) {
          float d = dist(centerXOfTile(xx), centerYOfTile(yy), centerX, centerY);
          if (d<dFound) {
            dFound = d;
            xFound = xx;
            yFound = yy;
          }
        }
      }
    }
    if (dFound<Float.POSITIVE_INFINITY) return new TileReference (xFound, yFound);
    else return null;
  }

  // True if the rectangle is completely inside tiles from the list
  //The meaning of x,y,w,h is governed by mode (CORNER, CENTER, CORNERS).
  public boolean testTileFullyInsideRect( float x, float y, float w, float h, String list ) {
    if (mode==CENTER) {
      x-=w/2;
      y-=w/2;
    }
    if (mode==CORNERS) {
      w=w-x;
      h=h-y;
    }
    float centerX=x+w/2, centerY=y+h/2;
    int startX = floor(x / tileSize),
      startY = floor(y / tileSize),
      endX   = floor((x+w) / tileSize),
      endY   = floor((y+h) / tileSize);

    for ( int xx = startX; xx <= endX; ++xx ) {
      for ( int yy = startY; yy <= endY; ++yy ) {
        if ( list.indexOf( at(xx, yy) ) == -1 ) return false;
      }
    }
    return true;
  }


  // Searches along the line from x1,y1 to x2,y2 for a tile from list
  // Returns the first found or null if none.
  public TileReference findTileOnLine( float x1, float y1, float x2, float y2, String list ) {
    TileReference ref = newRefOfPixel (x1, y1);
    int ctr=0;
    int maxCtr = floor(abs(x1-x2)+abs(y1-y2))/tileSize+3;
    while (ctr<=maxCtr && (ref.xPixel!=x2 || ref.yPixel!=y2)) {
      if (ctr>0) ref.advanceTowards (x2, y2);
      if (list.indexOf(at(ref.x, ref.y))!=-1) {
        ref.setBorders ();
        return ref;
      }
      ctr++;
    }
    if (ctr>maxCtr) println ("Internal error in Map:findTileOnLine");
    return null;
  }

  // Returns, whether on the line from x1,y1 to x2,y2 there is a tile from list
  public boolean testTileOnLine ( float x1, float y1, float x2, float y2, String list ) {
    return findTileOnLine (x1, y1, x2, y2, list)!=null;
  }

  // Draws the map on the screen, where the origin, i.e. left/upper
  // corner of the map is drawn at \c leftX, topY regardless of mode
  public void draw( float leftX, float topY ) {
    pushStyle();
    imageMode(CORNER);
    int startX = floor(-leftX / tileSize),
      startY = floor(-topY / tileSize);
    for ( int y = startY; y < startY + height/tileSize + 2; ++y ) {
      for ( int x  = startX; x < startX + width/tileSize + 2; ++x ) {
        PImage img = null;
        char tile = at( x, y );
        if ( tile == '_' )
          img = outsideImage;
        else if ('A'<=tile && tile<='Z')
          img = images[at( x, y ) - 'A'];
        if ( img != null )
          image( img,
            x*tileSize + leftX,
            y*tileSize + topY,
            tileSize, tileSize );
      }
    }
    popStyle();
  }

  // Loads a map file
  // element size is obtained from the first image loaded
  public void loadFile( String mapFile ) {
    map = loadStrings( mapFile );
    if (map==null)
      throw new Error ("Map "+mapFile+" not found.");
    while (map.length>0 && map[map.length-1].equals (""))
      map = shorten(map);
    h = map.length;
    if ( h == 0 )
      throw new Error("Map has zero size");
    w = map[0].length();

    // Load images
    for (char c='A'; c<='Z'; c++)
      images[c - 'A'] = loadImageRelativeToMap (mapFile, c + ".png" );
    outsideImage = loadImageRelativeToMap (mapFile, "_.png");

    for ( int y = 0; y < h; ++y ) {
      String line = map[y];
      if ( line.length() != w )
        throw new Error("Not every line in map of same length");

      for ( int x = 0; x < line.length(); ++x ) {
        char c = line.charAt(x);
        if (c==' ' || c=='_') {
        } else if ('A'<=c && c<='Z') {
          if (images[c - 'A'] == null)
            throw new Error ("Image for "+c+".png missing");
        } else throw new Error("map must only contain A-Z, space or _");
      }
    }

    determinetileSize ();
  }

  // Saves the map into a file
  public void saveFile (String mapFile) {
    saveStrings (mapFile, map);
  }


  //********************************************************************************************
  //********* The code below this line is just for internal use of the library *****************
  //********************************************************************************************

  // Internal: load and Image and return null if not found
  protected PImage tryLoadImage (String imageFilename) {
    //println("Trying "+imageFilename);
    if (createInput(imageFilename)!=null) {
      //println("Found");
      return loadImage (imageFilename);
    } else return null;
  }

  // Internal: Loads an image named imageName from a locatation relative
  // to the map file mapFile. It must be either in the same
  // directory, or in a subdirectory images, or in a parallel
  // directory images.
  protected PImage loadImageRelativeToMap (String mapFile, String imageName) {
    File base = new File(mapFile);
    File parent = base.getParentFile();
    PImage img;
    img = tryLoadImage (new File (parent, imageName).getPath());
    if (img!=null) return img;
    img = tryLoadImage (new File (parent, "data/images/"+imageName).getPath());
    if (img!=null) return img;
    img = tryLoadImage (new File (parent, "../data/images/"+imageName).getPath());
    return img;
  }

  // Goes through all images loaded and determine stileSize as amx
  // If image sizes are not square and equal a warning message is printed
  protected void determinetileSize () {
    tileSize = 0;
    PImage[] allImages = (PImage[]) append (images, outsideImage);
    for (int i=0; i<allImages.length; i++) if (allImages[i]!=null) {
      if (tileSize>0 &&
        (allImages[i].width!=tileSize || allImages[i].height!=tileSize))
        println ("WARNING: Images are not square and of same size");
      if (allImages[i].width>tileSize)  tileSize = allImages[i].width;
      if (allImages[i].height>tileSize) tileSize = allImages[i].height;
    }
    if (tileSize==0) throw new Error ("No image could be loaded.");
  }

  // If the dimension of the map is below width times height
  // _ are appended in each line and full lines are appended
  // such that it is width times height.
  protected void extend (int width, int height) {
    while (height>h) {
      map = append(map, "");
      h++;
    }
    if (w<width) w = width;
    for (int y=0; y<h; y++) {
      while (map[y].length ()<w)
        map[y] = map[y] + "_";
    }
  }

  // Replaces s.charAt(index) with ch
  public String replace (String s, int index, char ch) {
    return s.substring(0, index)+ch+s.substring(index+1, s.length());
  }


  // *** variables ***
  // tile x, y is map[y].charAt(x)
  String map[];
  // images[c-'A'] is the image for tile c
  PImage images[];
  // special image drawn outside the map
  PImage outsideImage;
  // map dimensions in tiles
  int w, h;
  // width and height of an element in pixels
  int tileSize;
}
interface Observer {
  void update(Object observer);
  void updateActionCount(Observer observer, int actionCount);
  void updateGrowthStatus(Observer observer, int growthStatus);
  void updateCropSelection(Observer observer, int cropSelection);
  void updateNotifyPoints(Observer observer, int points);
}

class InteractionHandler implements Observer {
  boolean interactionAllowed;

  public void update(Object data) {
    // so basically keep intersections in here
  }

  public void updateActionCount(Observer observer, int actionCount) {
  }

  public void updateGrowthStatus(Observer observer, int growthStatus) {
  }

  public void updateCropSelection(Observer observer, int cropSelection) {
  }

  public void updateNotifyPoints(Observer observer, int points) {
  }
}
// observable -> notifies observers about state

class ObserverSubject {
  // intersection between player and crops
  ArrayList<Observer> watchList = new ArrayList<Observer>();

  public void addObserver(Observer observer) {
    this.watchList.add(observer);
  }

  public void removeObserver(Observer observer) {
    this.watchList.remove(observer);
  }

  public void notifyObservers(Object data) {
    for (Observer observer : this.watchList ) {
      observer.update(data);
    }
  }

  public void notifyObserversActionCount(int actionCount) {
    for (Observer observer : this.watchList ) {
      observer.updateActionCount(observer, actionCount);
    }
  }

  public void notifyGrowthStatus( int growthStatus) {
    for (Observer observer : this.watchList ) {
      observer.updateGrowthStatus(observer, growthStatus);
    }
  }

  public void notifyCropSelection ( int cropSelection) {
    for (Observer observer : this.watchList ) {
      observer.updateCropSelection(observer, cropSelection);
    }
  }

  public void notifyPoints( int points ) {
    for (Observer observer : this.watchList ) {
      observer.updateNotifyPoints(observer, points);
    }
  }
}
class UI implements Observer {
  PImage menubar;

  Crops crops;

  // tools
  PImage seedCarrot;
  PImage seedPumpkin;
  PImage seedTomato;
  PImage seedKohl;
  PImage seedChoy;
  PImage seedEggplant;
  PImage watercan;
  PImage seedling;

  int fontSize = 16;
  int textColour = 0xFF272736;
  float seedPosX = 65;
  float seedPosY = 189;



  public void setup() {
    menubar = loadImage("images/menu.png");
    seedCarrot = loadImage("images/carrot.png");
    seedPumpkin = loadImage("images/adult.png");
    seedTomato = loadImage("images/tomato.png");
    seedKohl = loadImage("images/kohl.png");
    seedChoy = loadImage("images/bokchoy.png");
    seedEggplant = loadImage("images/eggplant.png");
    watercan = loadImage("images/watercan.png");
    seedling = loadImage("images/seeds.png");

    registerObserver(observerSubject);
  }

  public void draw() {
    textAlign(RIGHT);
    fill(textColour);
    textSize(fontSize);
    image(menubar, 0, 0);
    updateNotifyPoints(interactionHandler, player.pointsAdded);

    updateActionCount( interactionHandler, player.actionCount);

    movementsDisplay();
    noFill();
    updateCropSelection(interactionHandler, player.CROPSELECTION);
    toolsDisplay();
  }

  public void toolsDisplay() {
    pixelFont.draw("P", width-86, 26);
    // key instruction for plant seeds
    pixelFont.draw("X", width-90, 164);
    // watering
    image(watercan, width-90, 234);
    pixelFont.draw("H", width-90, 234);
    // harvesting
    pixelFont.draw("Q", width-90, 304);
  }

  public void movementsDisplay() {
    pixelFont.draw("W", 45, height-60);
    pixelFont.draw("S", 45, height-40);
    pixelFont.draw("A", 30, height-40);
    pixelFont.draw("D", 60, height-40);
  }

  public void registerObserver( ObserverSubject observerSubject) {
    observerSubject.addObserver(this);
  }

  public void update(Object data) {
  }

  public void updateCropSelection(Observer observer, int cropSelection) {
    imageMode(CENTER);

    // seed always displayed
    image(seedling, width-seedPosX, seedPosY);
    switch(cropSelection) {
    case 0:
      // TODO: change to pumpkin once exists
      image(seedPumpkin, width-seedPosX, seedPosY, seedPumpkin.width/2, seedPumpkin.height/2);
      break;
    case 1:
      image(seedTomato, width-seedPosX, seedPosY, seedTomato.width/2, seedTomato.height/2);
      break;
    case 2:
      image(seedCarrot, width-seedPosX, seedPosY, seedCarrot.width/2, seedCarrot.height/2);
      break;
    case 3:
      image(seedKohl, width-seedPosX, seedPosY, seedCarrot.width/2, seedCarrot.height/2);
      break;
    case 4:
      image(seedChoy, width-seedPosX, seedPosY, seedCarrot.width/2, seedCarrot.height/2);
      break;
    case 5:
      image(seedEggplant, width-seedPosX, seedPosY, seedCarrot.width/2, seedCarrot.height/2);
      break;
    }
    imageMode(CORNER);
  }

  // step counter
  public void updateActionCount(Observer observer, int actionCount) {
    String actionCountStr = str(actionCount);
    pixelFont.draw(actionCountStr + "/50", 30, 30);
  }

  public void updateGrowthStatus(Observer observer, int growthStatus) {
  }

  public void updateNotifyPoints(Observer observer, int points) {
    points += points;
    String pointsStr = str(points);
    pixelFont.draw(pointsStr, 45, 77);
  }
}
class Crops implements Observer {

  PImage seed;
  PImage seedling;
  PImage youngAdult;
  PImage adult;
  PImage dead;
  // width & size
  float cropW, cropH;
  // crop pos
  float cropX, cropY;
  // crop growth status
  int lifeCycle = 1;

  // state machine for crops
  int GROWSTATUS;
  int SEED = 0;
  int YOUNG = 1;
  int YOUNGADULT = 2;
  int ADULT = 3;
  int DEAD = 4;

  int growThreshold;

  // how many points you gain
  int cropPoints;

  // water level
  int hydrationLevel;

  // reference for steps
  int previousActionCount = 0;

  int cropType;
  Crops crops;

  Crops(float cropX, float cropY) {
    this.cropX = cropX;
    this.cropY = cropY;
    growThreshold = 10;
    cropW = 50;
    cropH = 50;
    hydrationLevel = 10;

    cropPoints = 10;
    seed = loadImage("images/seeds.png");
    seedling = loadImage("images/seedling.png");
    // fallback
    youngAdult = loadImage("images/youngadult.png");
    adult = loadImage("images/adult.png");
    dead = loadImage("images/dead.png");
  }

  public int getHydration() {
    return hydrationLevel;
  }

  public void hydrate() {
    if ( GROWSTATUS != DEAD ) {
      hydrationLevel += 10;
    }
  }

  public Crops checkNeighbour() {
    return crops;
  }

  public int checkGrowthStatus() {
    return GROWSTATUS;
  }

  public void registerObserver( ObserverSubject observerSubject) {
    observerSubject.addObserver(this);
  }

  public void update(Object observer) {
    // Implement how Crops respond to updates from observers (if needed)
  }

  public void updateNotifyPoints(Observer observer, int points) {
  }

  public void updateCropSelection(Observer observer, int cropSelection) {
  }

  public void updateActionCount(Observer observer, int actionCount) {
    if ( actionCount != previousActionCount && GROWSTATUS != DEAD) {
      if (observer instanceof Crops) {
        Crops crop = (Crops) observer;
        crop.hydrationLevel--;
      }
      lifeCycle++;
      previousActionCount = actionCount;
    }
  }

  public void updateGrowthStatus(Observer observer, int growthStatus) {
    if (observer instanceof Crops) {
      Crops crop = (Crops) observer;
      crop.checkGrowthStatus();
    }
  }

  public void growCrops() {
    imageMode(CENTER);
    if ( hydrationLevel > 1 ) {
      // seeds have the same parameter
      if (lifeCycle >= 1 && lifeCycle <= 2 ) {
        image(seed, cropX, cropY);
        GROWSTATUS = SEED;
      } else if ( lifeCycle >= 2 && lifeCycle <= (growThreshold/2) ) {
        image(seedling, cropX, cropY);
        GROWSTATUS = YOUNG;
      } else if ( lifeCycle >= 5 && lifeCycle <= growThreshold ) {
        image(youngAdult, cropX, cropY);
        GROWSTATUS = YOUNGADULT;
      } else if ( lifeCycle >= growThreshold+1 ) {
        image(adult, cropX, cropY);
        GROWSTATUS = ADULT;
      }
    } else if ( hydrationLevel <= 1 ) {
      image(dead, cropX, cropY);
      GROWSTATUS = DEAD;
    }
    observerSubject.notifyGrowthStatus(GROWSTATUS);
    imageMode(CORNER);
  }

  public void draw() {
    growCrops();
  }
}
class Font {
  PImage fontSheet;
  PImage[] characters;
  int lineHeight;
  int base;
  int charCount;
  float spacing = 8;

  Font() {
    fontSheet = loadImage("WhitePeaberryOutline.png");
    parseFontInfo("WhitePeaberryOutline.xml");
  }

  // bitmap font so we pass whatever string we want in here
  public void draw(String text, float x, float y) {
    for (int i = 0; i < text.length(); i++) {
      char letter = text.charAt(i);

      if (letter == ' ') { // Handle space character separately
        x += spacing; // Add spacing for the space character
      } else {
        // otherwise lowercase would register as empty
        if (Character.isLowerCase(letter)) {
          letter = Character.toUpperCase(letter);
        }
        // - ASCI
        int index = letter -32;
        if (index >= 0 && index < characters.length && characters[index] != null) {
          image(characters[index], x, y);
          x += characters[index].width-9; // Add some spacing between characters
        }
      }
    }
  }

  public void parseFontInfo(String filename) {
    XML fontXML = loadXML(filename);
    if (fontXML != null) {
      XML info = fontXML.getChild("info");
      lineHeight = info.getInt("lineHeight");
      base = info.getInt("base");

      XML chars = fontXML.getChild("chars");
      charCount = chars.getInt("count");
      characters = new PImage[charCount];

      XML[] charElements = chars.getChildren("char");
      for (int i = 0; i < charElements.length; i++) {
        XML charElement = charElements[i];
        int id = charElement.getInt("id") - 32; // Subtract 32 to convert from 1-based index to 0-based index
        int x = charElement.getInt("x");
        int y = charElement.getInt("y");
        int width = charElement.getInt("width");
        int height = charElement.getInt("height");
        int xoffset = charElement.getInt("xoffset");
        int yoffset = charElement.getInt("yoffset");
        characters[id] = fontSheet.get(x, y, width, height);
      }
    } else {
      println("Error loading XML file");
    }
  }
}
class Player {
  // Position of player center in level coordinates
  // also starting value
  float playerX = width-120, playerY = 40;

  // animation from lecture
  public ArrayList<PImage> loadImages (String filePattern) {
    // Count number of question marks
    String qmString="";
    while (filePattern.indexOf (qmString+"?")>=0) qmString += "?";
    // The largest sequence of question marks is qmString
    ArrayList<PImage> images = new ArrayList<PImage>();
    PImage image;
    int ctr=0;
    do {
      String fname = filePattern.replace(qmString, nf(ctr, qmString.length()));
      InputStream input = createInput(fname);
      if (input==null) break;
      PImage img = loadImage (fname);
      if (img==null) break;
      images.add(img);
      ctr++;
    } while (true);
    return images;
  }

  ArrayList<PImage> playerImgs;
  int playerPhase;
  float xVelocity = 32;  // Fox velocity in x direction in pixels per second
  float yVelocity = 16;  // Fox velocity in y direction in pixels per second
  int animationStepsPerSecond = 8; // How many images per second
  float phaseLength = 1.0f / animationStepsPerSecond; // Time for which one image is shown
  float subPhase = 0; // Timer for currently shown image
  boolean isMoving = false;

  // Velocity of player

  // Speed at which the player moves
  float playerSpeed = 10;

  float playerVX, playerVY;
  float nextX = playerX + playerVX;
  float nextY = playerY + playerVY;

  int actionCount = 0;
  int growthCeck;
  int pointsAdded;

  // The player is a circle and this is its radius
  float playerR = 10;

  // string gets sent to observer. Technically it would be cleaner to implement a real state machine or pattern but it's kind of overkill for the project so this will do.
  String onCrop;

  // debatable whether this should go into Crops or Player but since the player picks a seed (e.g. action) it's in here
  IntList cropSelection;

  int CROPSELECTION;
  int PUMPKIN = 0;
  int TOMATO = 1;
  int CARROT = 2;
  int KOHL = 3;
  int BOKCHOY = 4;
  int EGGPLANT = 5;

  // invoke without adjusted parameters
  Player() {
    playerPhase = 0;
    playerImgs = loadImages("animation/fx-??.png");
    animationStepsPerSecond = 8;
    phaseLength = 1.0f / animationStepsPerSecond;
    subPhase = 0;
    setCropList();
  }

  Player(float tempPlayerX, float tempPlayerY, float tempPlayerVX, float tempPlayerVY, float tempPlayerSpeed, float tempPlayerR) {
    playerX = tempPlayerX;
    playerY = tempPlayerY;
    playerVX = tempPlayerVX;
    playerVY = tempPlayerVY;
    playerSpeed = tempPlayerSpeed;
    playerR = tempPlayerR;
    setCropList();
  }

  public void setCropList() {
    // create list of all crops so we can iterate through it
    cropSelection = new IntList();
    cropSelection.append(PUMPKIN);
    cropSelection.append(TOMATO);
    cropSelection.append(CARROT);
    cropSelection.append(KOHL);
    cropSelection.append(BOKCHOY);
    cropSelection.append(EGGPLANT);
  }

  public void setPlayerPos(float setVX, float setVY) {
    playerVX = setVX;
    playerVY = setVY;
  }

  // Method to update player animation
  public void updateAnimation() {
    if (isMoving) {
      subPhase += 1.0f / frameRate; // Measure time of currently shown image
      if (subPhase > phaseLength) { // If time per image is reached ...
        subPhase = 0; // ... reset timer and

        playerPhase++; // go to next animation phase

        // down animation
        if ( playerPhase == 4 ) {
          playerPhase = 1;
        }

        // left animation
        if ( playerPhase == 9 ) {
          playerPhase = 5;
        }

        // down animation
        if ( playerPhase == 14 ) {
          playerPhase = 10;
        }

        if ( playerPhase == 19 ) {
          playerPhase = 15;
        }

        if (playerPhase >= playerImgs.size()) {
          playerPhase = 0; // Loop back to the start of animation if end is reached
        }
      }
    } else {
      // Player is not moving, set animation phase to stationary frame
      subPhase = 0;
      playerPhase = 0; // Set to the stationary frame
    }
  }

  public void updatePlayer() {
    if ( map.testTileInRect( nextX-playerR, nextY-playerR, 2*playerR, 2*playerR, map.emptyField ) ) {
      // tile can be planted on
      onCrop = "onSoil";
    } else if ( map.testTileInRect( nextX-playerR, nextY-playerR, 2*playerR, 2*playerR, map.tilled ) || map.testTileInRect( nextX-playerR, nextY-playerR, 2*playerR, 2*playerR, "H" ) ) {
      // planted tile, either hydrated or not
      onCrop = "onCrop";
    } else {
      onCrop = "notOnCrop";
    }

    // error was that we were extending the observersbj instead of just calling on it here
    updateAnimation();

    playerX = nextX;
    playerY = nextY;
  }

  public float getX() {
    return playerX;
  }

  public float getY() {
    return playerY;
  }

  public void drawPlayer() {
    // draw player
    noStroke();
    fill(0xFF2E2A2A, 122);
    ellipseMode(CENTER);
    imageMode(CENTER);
        ellipse( playerX , playerY+20, 2*playerR+10, playerR );
    image(playerImgs.get(playerPhase), playerX, playerY);
 
    imageMode(CORNER);
  }

  public void keyPressed() {
    if ( key == 'w' || key == 'W' ) {
      playerPhase = 11;
      if (nextY <= 0) {
        nextY = 0;
      } else {
        nextY = nextY - playerSpeed;
      }
    } else if ( key == 's' || key == 'S'  ) {
      playerPhase = 1;
      if ( nextY >= height ) {
        nextY = height;
      } else {
        nextY = nextY + playerSpeed;
      }
    } else if ( key == 'a' || key == 'A') {
      playerPhase = 6;
      if ( nextX <= 0 ) {
        nextX = 0;
      } else {
        nextX = nextX - playerSpeed;
      }
    } else if ( key == 'd' || key == 'D' ) {
      playerPhase = 16;
      if ( nextX >= width ) {
        nextX = width;
      } else {
        nextX = nextX + playerSpeed;
      }
    } else {
      // allow actions
      actions();
    }

    //animation
    if ((key == 'w' || key == 'W' || key == 's' || key == 'S' || key == 'a' || key == 'A' || key == 'd' || key == 'D') && !isMoving) {
      isMoving = true;
    }
    // select crop called only when key is pressed
    selectCrop();
    // update movement
    updatePlayer();
  }

  public void keyReleased() {
    if ( key == 'w' || key == 'W'  ) {
      nextY = 0;
    } else if ( key == 's' || key == 'S' ) {
      nextY = 0;
    } else if ( key == 'a' || key == 'A'  ) {
      nextX = 0;
    } else if ( key == 'd' || key == 'D' ) {
      nextX = 0;
    }
    if ((key == 'w' || key == 'W' || key == 's' || key == 'S' || key == 'a' || key == 'A' || key == 'd' || key == 'D') && isMoving) {
      isMoving = false;
    }
  }

  public void actions() {
    // should only be allowed on seed so probably good idea to store a boolean and use observer to update that
    Map.TileReference soil = map.findTileInRect
      (playerX, playerY, playerR*2, playerR*2, map.emptyField);

    Map.TileReference tilled = map.findTileInRect
      (playerX, playerY, playerR*2, playerR*2, map.tilled);

    Map.TileReference tilledWatered = map.findTileInRect
      (playerX, playerY, playerR*2, playerR*2, map.tilledWatered);

    if (keyPressed) {
      // planting a seed
      if ( (key == 'x' || key == 'X') && soil != null ) {

        //cropList.add(new Crops(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
        // make field tilled
        plantSeed(soil);
        map.set (soil.x, soil.y, 'H');
        actionCount++;
      } else if (( key == 'h' || key == 'H') && tilled != null  ) {
        // find crop, if there is crop do action.
        checkForCrops(tilled);
        map.set (tilled.x, tilled.y, 'M');
        actionCount++;
      } else if ((key == 'q' || key == 'Q')) {
        if ( tilled != null ) {
          checkForCrops(tilled);
        } else if ( tilledWatered != null ) {
          checkForCrops(tilledWatered);
        }
      }

      // trigger each time key is pressed
      soilHydrationReset();
    }

    // lets observer know
    observerSubject.notifyObserversActionCount(actionCount);
  }

  public void soilHydrationReset() {
    for (int x = 0; x < map.w; x++) {
      for (int y = 0; y < map.h; y++) {
        // Check if the tile is tilled and watered
        if (map.at(x, y) == map.tilledWatered.charAt(0)) {
          // Check if there is a crop at this location
          for (Crops crop : cropList) {
            if (crop.cropX == map.centerXOfTile(x) && crop.cropY == map.centerYOfTile(y)) {
              // Check the hydration level of the crop
              if (crop.hydrationLevel < 10) {

                // Reset the tile to just tilled
                map.set(x, y, map.tilled.charAt(0));
                break; // No need to check other crops for this tile
              }
            }
          }
        }
      }
    }
  }



  public int selectCrop() {
    if (keyPressed) {
      if (keyCode == RIGHT) {
        if (CROPSELECTION < cropSelection.size()-1 ) {
          CROPSELECTION++;
        } else {
          CROPSELECTION = 0;
        }
      } else if (keyCode == LEFT) {
        if (CROPSELECTION <= 0) {

          CROPSELECTION = cropSelection.size()-1;
        } else {
          CROPSELECTION--;
        }
      }
    }
    // at the end we need to notify observer about changed seed for the display
    observerSubject.notifyCropSelection(CROPSELECTION);
    return CROPSELECTION;
  }

  public void plantSeed(Map.TileReference soil) {
    switch(CROPSELECTION) {
    case 0:
      cropList.add(new Pumpkin(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
      break;
    case 1:
      cropList.add(new Tomato(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
      break;
    case 2:
      cropList.add(new Carrot(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
      break;
    case 3:
      cropList.add(new Kohl(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
      break;
    case 4:
      cropList.add(new Bokchoy(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
      break;
    case 5:
      cropList.add(new Eggplant(map.centerXOfTile(soil.x), map.centerYOfTile(soil.y)));
      break;
    }

    observerSubject.notifyObservers(cropList);
  }


  public void checkForCrops(Map.TileReference tile) {
    for (Crops crop : cropList) {
      // Calculate the distance between player and crop
      float dx = playerX - crop.cropX;
      float dy = playerY - crop.cropY;
      float distance = sqrt(dx * dx + dy * dy);
      int growthStatus = crop.checkGrowthStatus();

      // Check if in crop
      if (distance < playerR + crop.cropW/2) {
        switch(growthStatus) {
        case 4:
          // dead
          cropList.remove(crop);
          // reset field
          map.set (tile.x, tile.y, 'D');
          actionCount++;
          break;
        case 3:
          // harvest
          cropList.remove(crop);

          // reset field
          map.set (tile.x, tile.y, 'D');

          actionCount++;
          // add to player point count
          pointsAdded += crop.cropPoints;
          observerSubject.notifyPoints(player.pointsAdded);
          break;
        default:
          // hydrate
          crop.hydrate();
          break;
        }

        return; // Exit the loop if a crop is found
      }
    }
  }
}

class Tomato extends Crops {

  Tomato(float cropX, float cropY) {
    super(cropX, cropY);

    // easier
    growThreshold = 12;
    cropPoints = 6;

    youngAdult = loadImage("images/youngtomato.png");
    adult = loadImage("images/tomato.png");
  }
}

class Pumpkin extends Crops {
  Pumpkin(float cropX, float cropY) {
    super(cropX, cropY);

    cropPoints = 13;

    youngAdult = loadImage("images/youngadult.png");
    adult = loadImage("images/adult.png");
  }
}

class Carrot extends Crops {
  Carrot(float cropX, float cropY) {
    super(cropX, cropY);

    // easier
    growThreshold = 10;
    hydrationLevel = 5;
    cropPoints = 8;

    youngAdult = loadImage("images/youngcarrot.png");
    adult = loadImage("images/carrot.png");
  }
}

class Kohl extends Crops {
  Kohl(float cropX, float cropY) {
    super(cropX, cropY);

    // long time
    growThreshold = 20;
    cropPoints = 25;

    youngAdult = loadImage("images/youngkohl.png");
    adult = loadImage("images/kohl.png");
  }

  public void hydrate() {
    if ( GROWSTATUS != DEAD ) {
      hydrationLevel += 6;
    }
  }
}

class Bokchoy extends Crops {

  Bokchoy(float cropX, float cropY) {
    super(cropX, cropY);

    // easy
    growThreshold = 9;
    cropPoints = 3;
    hydrationLevel = 15;

    youngAdult = loadImage("images/babychoy.png");
    adult = loadImage("images/bokchoy.png");
  }
}

class Eggplant extends Crops {
  Eggplant(float cropX, float cropY) {
    super(cropX, cropY);

    // long time
    growThreshold = 13;
    hydrationLevel = 30;
    cropPoints = 5;

    youngAdult = loadImage("images/youngeggplant.png");
    adult = loadImage("images/eggplant.png");
  }

  public void hydrate() {
    if ( GROWSTATUS != DEAD ) {
      hydrationLevel += 5;
    }
  }
}


  public void settings() { size(640, 480); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "cozygame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
